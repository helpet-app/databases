CREATE TABLE accounts (
    id         UUID PRIMARY KEY,
    username   TEXT NOT NULL,
    name       TEXT NOT NULL,
    avatar_url TEXT
);
CREATE UNIQUE INDEX accounts_unique_username ON accounts (UPPER(username));

-- CREATE SUBSCRIPTION accounts_subscription_for_vet_service CONNECTION '...' PUBLICATION accounts_publication;

CREATE TABLE vets (
    account_id UUID PRIMARY KEY REFERENCES accounts (id),
    name       TEXT NOT NULL,
    bio        TEXT,
    avatar_url TEXT,
    available  BOOLEAN NOT NULL DEFAULT FALSE
);
CREATE INDEX vets_available ON vets (available);

CREATE TABLE vet_contacts (
    id     UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name   TEXT NOT NULL,
    value  TEXT NOT NULL,
    vet_id UUID NOT NULL REFERENCES vets (account_id)
);
CREATE INDEX vet_contacts_vet_fkey ON vet_contacts (vet_id);

CREATE TABLE vet_tariffs (
    id          UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name        TEXT NOT NULL,
    description TEXT,
    min_price   DOUBLE PRECISION NOT NULL CHECK (min_price >= 0),
    max_price   DOUBLE PRECISION CHECK (max_price >= min_price),
    vet_id      UUID NOT NULL REFERENCES vets (account_id)
);
CREATE INDEX vet_tariffs_vet_fkey ON vet_tariffs (vet_id);

CREATE TABLE tags (
    id   UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name TEXT NOT NULL UNIQUE
);
CREATE INDEX tags_name ON tags (UPPER(name));

CREATE TABLE vet_tags (
    vet_id UUID REFERENCES vets (account_id),
    tag_id UUID REFERENCES tags (id) ON DELETE CASCADE,
    PRIMARY KEY (vet_id, tag_id)
);
CREATE UNIQUE INDEX vet_tags_pkey_reverse ON vet_tags (tag_id, vet_id);

CREATE TABLE time_slots (
    id         INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    start_time TIME WITH TIME ZONE NOT NULL UNIQUE,
    end_time   TIME WITH TIME ZONE NOT NULL UNIQUE,
    CHECK (start_time < end_time)
);

CREATE TABLE vet_schedule (
    id           UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    vet_id       UUID NOT NULL REFERENCES vets (account_id),
    time_slot_id INTEGER NOT NULL REFERENCES time_slots (id) ON DELETE CASCADE,
    monday       BOOLEAN NOT NULL DEFAULT FALSE,
    tuesday      BOOLEAN NOT NULL DEFAULT FALSE,
    wednesday    BOOLEAN NOT NULL DEFAULT FALSE,
    thursday     BOOLEAN NOT NULL DEFAULT FALSE,
    friday       BOOLEAN NOT NULL DEFAULT FALSE,
    saturday     BOOLEAN NOT NULL DEFAULT FALSE,
    sunday       BOOLEAN NOT NULL DEFAULT FALSE,
    CHECK (monday OR tuesday OR wednesday OR thursday OR friday OR saturday OR sunday),
    UNIQUE (vet_id, time_slot_id)
);
CREATE INDEX vet_schedule_vet_fkey ON vet_schedule (vet_id);

ALTER SYSTEM SET wal_level = logical;

CREATE PUBLICATION vets_publication FOR TABLE vets (account_id, name, avatar_url, available), time_slots, vet_schedule WITH (PUBLISH = 'INSERT,UPDATE,DELETE,TRUNCATE');

CREATE OR REPLACE FUNCTION find_all_vets_by_filter(
    tag_ids UUID[]
)
    RETURNS SETOF UUID
AS
$$
BEGIN
    IF tag_ids IS NULL OR CARDINALITY(tag_ids) = 0 THEN
        RETURN QUERY
            SELECT v.account_id
            FROM vets AS v
            WHERE v.available
            ORDER BY v.account_id;
        RETURN;
    END IF;

    RETURN QUERY
        SELECT v.account_id
        FROM vets AS v
                 INNER JOIN vet_tags AS vt ON v.account_id = vt.vet_id
        WHERE v.available
          AND vt.tag_id = ANY (tag_ids)
        GROUP BY v.account_id
        ORDER BY v.account_id;
END;
$$ LANGUAGE PLPGSQL;

DO
$$
    BEGIN
        FOR hour IN 0..23
            LOOP
                INSERT INTO time_slots (start_time, end_time) VALUES (MAKE_TIME(hour, 0, 0), MAKE_TIME(hour, 30, 0));
                INSERT INTO time_slots (start_time, end_time)
                VALUES (MAKE_TIME(hour, 30, 0), MAKE_TIME(hour + 1, 0, 0));
            END LOOP;
    END
$$;